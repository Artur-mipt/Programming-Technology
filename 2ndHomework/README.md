Код-стайл от ABBYY: https://drive.google.com/file/d/0B6oYnrxwl0UcLTRDVHNxVGxJeUU/view

<b> В папке 1stHomework реализована игра-стратегия для двух игроков. </b>

Суть игры:
1) 1-ый игрок играет за команду террористов; 2-ой игрок играет за команду контр-террористов.

2) Каждый игрок может добавить в свою команду, например, пять бойцов. Игроки добавляют новых юнитов в команду по очереди. Так они в реальном времени подстраиваются под выбор соперника и решают, какого юнита добавить на очередном шаге.

3) Юниты бывают разных типов:
Террористы - StormTrooper, Sniper, Doctor, BombHostage
Контр-террористы - StormTrooper, Sniper, Doctor, Sapper

4) Причем у каждого типа есть свои особенности. Например, у штурмовика (StormTrooper) есть гранаты и штурмовая винтовка, а медик (Doctor) способен восстанавливать здоровье союзников.

5) Более того, юниты одного типа, но из разных команд, тоже отличаются друг от друга. Так, например, у штурмовика-террориста винтовка - АК47, а у контр-террориста винтовка - M4A1.

Особенности реализации:
1) При реализации используется паттерн проектирования Factory Method. Конкретные юниты контр-террористов или террористов наследуются от некоторых абстрактных классов юнитов. Для создания новых юнитов используются фабрики. Так как команды всего две, то нет необходимости в реализации класса Abstract Factory, поэтому сразу без какого-либо наследования реализованы фабрики для создания террористов и контр-террористов.

2) Классы конкретных боевых единиц террористов и контр-террористов реализованы в файле "ConcreteUnits.h". При их реализации используется наследование от абстрактных классов. Так, например, снайпер-террорист TSniper и снайпер-контр-террорист CTSniper наследуются от класса Sniper, который, в свою очередь, наследуются от наиболее абстратктного класса Unit. Интерфейсы абстрактных классов описаны в файле "AbstractUnits.h".

3) Сами составы команд хранятся в классах Terrorists и CTerrorists. Они реализованы в файлах "Terrorists.h" и "Counter-Terrorists.h" соответственно. В каждом из них есть функция добавления нового юнита в команду. Добавление происходит как раз при помощи фабрики. Так, например, при вызве функции AddTerrorist("BombHostage") с помощью специальной фабрики создания террористов создастся новый объект типа BombHostage и указатель на него добавится в конец вектора vector <BombHostage*> bombers. Фабрики реализованы в файле "Creators.h".

4) Для вывода информации о командах реализован класс Info(). Там же выводится суммарное здоровье для конкретной команды (для этого используется паттерн Composite, который реализован в функциях GetHealth() для классов Terrorists и Counter-Terrorists).

5) Процесс игры описан в "main.cpp". Игроки по очереди добавляют юнитов в свои команды и в конце с помощью специального метода Info() выводятся итоговые составы команд, чтобы игроки могли сравнить свои силы.

6) Также реализован паттерн Composite: метод GetHealth классов Terrorists и CounterTerrorists считает суммарное здоровье юнитов каждой из команд.



<b> В папке 2ndHomework содержится вторая (улучшенная) версия игры. </b>

Что нового:
1) Добавлена возможность считать суммарный разовый дамаг всей команды.

2) Добавлена возможность апгрейдить юнитов, то есть увеличивать у них показатели здоровья и урона.

3) Добавлена возможность следить за выполнением программы, при этом не изменяя код в основных классах.

Особенности реализации:
1) Для подсчитывания суммарного дамага был реализован паттерн Composite, так как он прекрасно работает с древовидной структурой, как в нашем проекте. По сравнению с первой версией, всех членов команды теперь храним в отдельном векторе vector <Unit*> allUnits (см. в классах Terrorists и CounterTerrorists). Для наглядности добавим метод GetDamage(), который выводит суммарный дамаг. Он итерируется по всем элементам вектора allUnits и вызывает от них метод UnitDamage(). Заметьте, что метод вызывается от объекта класса Unit, при этом он переопределен у конкретных юнитов (в зависимости от типа юнита метода UnitDamage() работает по-разному). Это и есть паттерн Composite, когда мы работаем с разными объектами одним и тем же способом, используя при этом нашу древовидную иерархию наследования конкретных юнитов от абстрактных.

2) Для апгрейда юнитов был реализован паттерн Decorator(см. в папке Decorator), так как он позволяет избежать множественного наследования и делает механизм апгрейда более понятным для разработчика. В ходе реализации был создан класс UpgradeWrapper - сам декоратор, и его наследники HealthUpgrade и DamageUpgrade. После чего определили функцию Upgrade для декораторов так, чтобы некоторого наследника класса Unit можно было сколько угодно раз "обёртывать" в классы-декораторы, тем самым увеличивая его игровые показатели.

3) Так как в игре нет ресурсоёмких объектов, а значит и оптимизировать там по сути нечего. Тогда паттерн Proxy был реализован для контроля работы программы. В папке Proxy хранятся наследники классов Terrorists и CounterTerrorists, и если мы будем работать уже с их наследниками, то при вызове каждого метода в stdout будет выводиться, какой метод мы вызываем. Так мы контролируем ход работы программы, при этом не меняя ничего в основных классах - это и есть Proxy.