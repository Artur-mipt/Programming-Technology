<b> <h1> Игра - "Counter-strike на память" </h1> </b>

<b> <h2> Установка </h2> </b>

1) Загрузить всё содержимое папки 3rdHomework (это финальная версия) в пустой проект в CLion.

2) Запустить main.cpp

3) Играть!


<b> <h2> Геймплей </h2> </b>

1) В игру может играть два человека. Первый играет за команду террористов, второй - за контр-террористов.
Вначале игрокам предлагается добавить по пять юнитов в свои команды. В команду можно добавлять снайперов (Sniper),
штурмовиков (StormTrooper), медиков (Doctor). Также террористы могут добавить 
закладчика бомбы (BombHostage), а контр-террористы - сапёра (Sapper).
Разумеется, у разных юнитов - разные игровые показатели и возможности.

2) Если игроки хотят поиграть подольше, то после добавления юнитов в команды им будет предложена такая
возможность. Ввод "y" - положительный ответ, "n" - отрицательный. В случае положительного ответа у всех юнитов 
увеличится количество очков здоровья.

3) Затем начинается сам игровой процесс. Игроки по очереди либо атакуют друг друга, либо докторами лечат собственных юнитов.
Игра заканчивается, когда все юниты одной из команд умирают. Победившим считается игрок, оставшийся в живых.

4) Одна из фишек игры - тренировка памяти. Игрок должен помнить, под каким номером (1..5) находится тот или иной юнит (и свой, 
и противника), и сколько у него очков здоровья. Так случайно можно атаковать уже мертвого юнита или, например, пытаться лечить одного 
юнита снайпером (а снайпер не умеет лечить и ход будет потрачен зря).


<b> <h2> Реализация геймплея </h2> </b>

1) Используемый код-стал - код-стайл компании ABBYY: https://drive.google.com/file/d/0B6oYnrxwl0UcLTRDVHNxVGxJeUU/view

2) В папке 3rdHomework репозитория Programming Technology хранится реализация финальной версии игры.
 
3) Структура юнитов: есть абстрактный класс Unit, от него наследуются классы - юниты по специализациям (StormTrooper, Sniper, ...), а
от них наследуются классы конкретных юнитов (например, CTStormTrooper - штурмовик-контр-террорист). 

4) Классы команд террористов и контр-террористов реализованы в папках Terrorists и Counter-Terrorists. Каждый из этих классов хранит 
в себе вектор с указателями на всех юнитов той или иной команды, причём неизвестно, какой специализации принадрежит конкретный юнит 
из этого вектора.

5) Взаимодействует с командами специальный класс Gameplay, который отвечает и за набор составов команд, и за ход игры, и следит за тем,
чтобы игра закончилась вовремя.

6) Сам процесс игры и работа с объектом game класса Gameplay реализованы в файле main.cpp.

7) Для вывода информации в ходе игры был реализован класс PrintInfo в папке Information.


<b> <h2> Паттерн Factory Method </h2> </b>

1) Для создания новых юнитов используются фабрики. Их реализация находится в папке Creator.

2) Нет необходимости в Abstract Factory, т.к. команд всего две штуки и нет смысла вводить
иерархию фабрик.


<b> <h2> Паттерн Composite </h2> </b>

1) С помощью Composite можно узнавать суммарный разовый дамаг юнитов каждой из команд.

2) Composite работает с древовидной структурой наследования юнитов, и вызывая метод GetDamage() 
от абстрактного юнита спускается вниз по дереву и далее работа метода GetDamage зависит уже от 
специализации конкретного юнита, которую мы на самом деле не знаем.


<b> <h2> Паттерн Decorator </h2> </b> 

1) Вводит в игру возможность добавления апгрейда конкретных юнитов. 

2) Он позволяет избежать множественного наследования и делает механизм апгрейда более понятным для разработчика. 
В ходе реализации был создан класс UpgradeWrapper - сам декоратор, и его наследники HealthUpgrade и DamageUpgrade. 
После чего определили функцию Upgrade для декораторов так, чтобы некоторого наследника класса Unit можно было сколько 
угодно раз "обёртывать" в классы-декораторы, тем самым увеличивая его игровые показатели.


<b> <h2> Паттерн Proxy </h2> </b>

1) Proxy контролирует ход работы программы, при этом не меняя ничего в основных классах. С помощью него можно 
отслеживать, какая функция в какой момент вызывается.

2) В папке Proxy хранятся наследники классов Terrorists и CounterTerrorists, и если мы будем работать уже с этими 
наследниками, в которых слегка переопределены стандартные методы, то при вызове каждого метода в stdout будет 
выводиться, какой метод мы вызываем.


<b> <h2> Паттерн Command </h2> </b>

1) Работает с командами как с отдельными объектами. 

2) Абстрактный класс Command имеет единственный метод execute, который переопределён в его наследниках (конкретных 
командах). Так например, мы можем вопроспроизводить игровые действия уже после того, как игроки дали соотвествующие 
команды к совершению этих действий (просто храним команды в векторе).


<b> <h2> Паттерн Observer </h2> </b>

1) Одновременно взаимодействует с однородными объектами, как с одним.

2) Когда игрокам предлагается сыграть в "удлинённую версию" игры, создаётся subject, который хранит в себе наблюдателей,
отвечающих за апдейт конкретной команды. Тогда вызывая update от subject'а мы работаем с командами, как с единым целым.


<b> <h2> Отказ от паттерна CoR </h2> </b>

1) CoR раздаёт команды разным обработчикам, делающим по сути одно и то же, но это равномерно распределяет нагрузку.

2) В данной игре такой функционал не требуется, т.к. у нас всего две команды и не имеет смысл как-то распределять их 
методы по обработчикам.


<b> <h2> Отказ от паттерна Visitor </h2> </b>

1) Позволяет, не изменяя классы объектов, добавлять в них новые операции.

2) В данной игре такой функционал не требуется, т.к. все методы уже заранее определены и в ходе игры новых возникнуть 
не может.


<b> <h2> Тестирование </h2> </b>

1)  Для тестирования в папке Testing храним отдельный класс, в котором реализованы методы, проверяющие правильно ли работают использованные в проекте паттерна и возвращающие true иди false в зависимости от результата.

2) Само тестирование осуществляем из main.cpp.
